#!/usr/bin/env python

# ROS imports
import rospy
from std_msgs.msg import Float32MultiArray
from sensor_msgs.msg import JointState

# Python imports
import numpy as np
from numpy.random import sample
from scipy.fft import fft, ifft, fftfreq
from datetime import datetime
import matplotlib.pyplot as plt


class frequencyResponseAnalysisNode():
    def __init__(self) -> None:

        # define parameter server address
        node_param = "/frequency_response_analysis"

        # Get parameters from the parameter server
        rate_ = float(rospy.get_param(f"{node_param}/rate")) #Hz
        joint_ = str(rospy.get_param(f"{node_param}/joint"))
        self.desired_data_points = int(rospy.get_param(f"{node_param}/desired_data_points", "1000"))
        self.mean = float(rospy.get_param(f"{node_param}/mean"))
        self.std = float(rospy.get_param(f"{node_param}/std"))

        # Initialize the rosnode
        rospy.init_node("frequency_response_analysis", anonymous=True)
        rospy.loginfo("Starting frequency response analysis")
        rate = rospy.Rate(rate_) #250hz

        # # Initialize shutdown procedure
        rospy.on_shutdown(self.shutdown_node_processes)

        # Initialize measurement arrays
        self.position = np.array([])
        self.velocity = np.array([])
        self.effort = np.array([])

        # Create a dynamic reconfigure server
        # ...

        # Get joint names and index of joint to perform FRA on
        self.joint_names = rospy.get_param("/march/joint_names")
        self.joint_index = self.joint_names.index(joint_)

        # Initialize message data
        self.msg = Float32MultiArray()
        self.msg.data = np.zeros((len(self.joint_names),1))

        # Create the publisher for the feedforward message
        self.pub = rospy.Publisher('/march/joint_effort_feedforward', Float32MultiArray, queue_size=10)

        # Create the subscriber for storing the joint states
        self.sub = rospy.Subscriber("/march/joint_states", JointState, callback=self.get_measurements)
        
        # main loop
        while not rospy.is_shutdown() and len(self.effort) <= self.desired_data_points:
            
            # Generate gaussian white noise (gnw)
            feedforward = self.gaussian_white_noise()

            # Fill the message data
            self.msg.data[self.joint_index] = feedforward

            # Publish the feedforward data
            self.pub.publish(self.msg)

            # Sleep to achieve the defined update rate
            rate.sleep()

        # Shutdown the experiment in nice way
        rospy.loginfo("Gathered desired data points, shutting down experiment")
        self.shutdown_experiment()

        # Performing FRF estimation
        rospy.loginfo("Performing FRF estimation")
        self.estimate_frf()

        # Exit the node
        rospy.signal_shutdown("The FRA experiment has finished, shutting down the node")

        pass

    def gaussian_white_noise(self):
        output = np.random.normal(self.mean, self.std, size=1)
        return output

    def get_measurements(self, data):
        self.position = np.append(self.position, data.position[self.joint_index])
        self.velocity = np.append(self.velocity, data.velocity[self.joint_index])
        self.effort = np.append(self.effort, data.effort[self.joint_index])

    def estimate_frf(self):
        # Perform fft on the input and output
        Y_N = fft(self.position)
        U_N = fft(self.effort)

        # Make sure the arrays are the same size by finding the lowest length 
        # and using that in futher calculations
        N = min(len(Y_N), len(U_N))

        # Calculate the FRF (G_N)
        G_N = Y_N[:N]/U_N[:N]

        # # Generating Bode plot
        # dt = 1.0 / 50.0
        # freq = fftfreq(N, dt)[:N//2]
        # db2, phase2 = bode_utils.bode_plot2(freq, G_N)

        # Plotting results
        T = 1.0 / 50.0
        xf = fftfreq(N, T)[:N//2]
        
        plt.figure()
        plt.plot(xf, 2.0/N * np.abs(G_N[0:N//2]))
        plt.yscale("log")
        plt.xscale("log")
        plt.grid()
        plt.show()

    def save_measurements(self):
        # Create timestamp for naming the measurement data file
        timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")

        # Save FRA measurement data
        rospy.loginfo("Saving the measurement data")
        np.savez_compressed(f"frf_measurements_{self.joint_names[self.joint_index]}_{timestamp}", 
            position=self.position, velocity=self.velocity, effort=self.effort)

    def shutdown_node_processes(self):

        # Publish zero valued feedforward data
        self.msg.data = np.zeros((len(self.joint_names),1))
        self.pub.publish(self.msg)

        # Stop the subscriber
        self.sub.unregister()

    def shutdown_experiment(self):
        self.shutdown_node_processes()
        self.save_measurements()

        


if __name__ == '__main__':
    try:
        ros_node = frequencyResponseAnalysisNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
