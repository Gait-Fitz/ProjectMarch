#!/usr/bin/env python

# ROS imports
import rospy
from std_msgs import msg
from std_msgs.msg import Float32MultiArray
from std_msgs.msg import MultiArrayDimension
from sensor_msgs.msg import JointState

# Python imports
import numpy as np
from numpy.random import sample
from datetime import datetime


class frequencyResponseAnalysisNode():
    def __init__(self) -> None:

        # define parameter server address
        node_param = "/frequency_response_analysis"

        # Get parameters from the parameter server
        rate_ = float(rospy.get_param(f"{node_param}/rate", "250")) #Hz
        joint_ = str(rospy.get_param(f"{node_param}/joint"))
        self.mean = 0.0
        self.std = 1.0

        # Initialize the rosnode
        rospy.init_node("frequency_response_analysis", anonymous=True)
        rospy.loginfo("Starting frequency response analysis")
        rate = rospy.Rate(rate_) #250hz

        # Initialize shutdown procedure
        rospy.on_shutdown(self.shutdown)

        # Initialize measurement arrays
        self.position = np.array([])
        self.velocity = np.array([])
        self.effort = np.array([])

        # Create a dynamic reconfigure server
        # ...

        # Get joint names and index of joint to perform FRA on
        self.joint_names = rospy.get_param("/march/joint_names")
        self.joint_index = self.joint_names.index(joint_)

        # Initialize message data
        msg = Float32MultiArray()
        msg.data = np.zeros((len(self.joint_names),1))

        # Create the publisher for the feedforward message
        pub = rospy.Publisher('/march/feedforward', Float32MultiArray, queue_size=10)

        # Create the subscriber for storing the joint states
        rospy.Subscriber("/march/joint_states", JointState, callback=self.get_measurements)
        
        # main loop
        while not rospy.is_shutdown():

            # Generate gaussian white noise (gnw)
            gwn_data = self.gaussian_white_noise()

            # Fill the message data
            msg.data[self.joint_index] = gwn_data

            # Publish the feedforward data
            pub.publish(msg)

            # Sleep to achieve the defined update rate
            rate.sleep()

        pass


    def gaussian_white_noise(self):
        output = np.random.normal(self.mean, self.std, size=1)
        return output

    def get_measurements(self, data):
        self.position = np.append(self.position, data.position[self.joint_index])
        self.velocity = np.append(self.velocity, data.velocity[self.joint_index])
        self.effort = np.append(self.effort, data.effort[self.joint_index])

    def shutdown(self):
        # Create timestamp for naming the measurement data file
        timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")

        # Save FRA measurement data
        rospy.loginfo("Saving the measurement data")
        np.savez_compressed(f"frf_measurements_{self.joint_names[self.joint_index]}_{timestamp}", 
            position=self.position, velocity=self.velocity, effort=self.effort)

        # Performing FRF estimation
        # ...
        

if __name__ == '__main__':
    try:
        ros_node = frequencyResponseAnalysisNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
